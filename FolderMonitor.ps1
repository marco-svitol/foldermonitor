param (
    [Parameter(Mandatory=$true)][string]$sourcefolder,
    [Parameter(Mandatory=$true)][string]$destinationfolder
)

$maxwaitsecs = 600
$logfilepath = ("$($env:temp)\$($MyInvocation.MyCommand.Name)").Replace(".ps1","_$(get-date -f yyyy-MM-dd).log")
Add-content $logfilepath -value "$(Get-Date) FileWatcher started : monitoring $sourcefolder. Destionation folder is $destinationfolder and maxwaitsecs is $maxwaitsecs"

$filewatcher = New-Object System.IO.FileSystemWatcher ### SET FOLDER TO WATCH + FILES TO WATCH + SUBFOLDERS YES/NO
$filewatcher.Path = "$sourcefolder" #Mention the folder to monitor
$filewatcher.Filter = "*.*"
$filewatcher.IncludeSubdirectories = $true
$filewatcher.EnableRaisingEvents = $true  
$writeaction = {  #define action when event is triggered
        Function Test-IsFileLocked {
        [cmdletbinding()]
        Param (
            [parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True)]
            [Alias('FullName','PSPath')]
            [string[]]$Path
        )
        Process {
            ForEach ($Item in $Path) {
                #Ensure this is a full path
                $Item = Convert-Path $Item
                #Verify that this is a file and not a directory
                If ([System.IO.File]::Exists($Item)) {
                    Try {
                        $FileStream = [System.IO.File]::Open($Item,'Open','Write')
                        $FileStream.Close()
                        $FileStream.Dispose()
                        $IsLocked = $False
                    } Catch [System.UnauthorizedAccessException] {
                        $IsLocked = 'AccessDenied'
                    } Catch {
                        $IsLocked = $True
                    }
                    [pscustomobject]@{
                        File = $Item
                        IsLocked = $IsLocked
                    }
                }
            }
        }
    }

    Function SyncFiles($sourcefolder, $destinationfolder, $maxwaitsecs){
        try{
        # Get all files recurse
        $files = Get-ChildItem -Path $sourcefolder -Recurse -File | ForEach-Object { $_.FullName }
        # Iterate through the list moving files
        foreach( $file in $files ) {
            $i = 0;
            $elapsedtime = Measure-Command {while ((Test-IsFileLocked -Path $file).IsLocked -and ($i -lt $maxwaitsecs)) {sleep(1);$i++} }#wait maxwaitsecs if file is locked
            Add-content $logfilepath -value "Start moving $file to $destinationfolder after $($elapsedtime.TotalSeconds) seconds it has been created" 
            $destFile = $file.Replace( $sourcefolder, $destinationfolder )
            $destFolder = Split-Path -Path $destFile -Parent
            # Make sure the destination folder for the file exists
            if ( -not ( Test-Path -Path $destFolder ) ) {
                [void](New-Item -Path ( Split-Path -Path $destFolder -Parent ) -Name ( Split-Path -Path $destFolder -Leaf ) -ItemType Directory -Force)
            }
            $elapsedtime = Measure-Command {Copy-Item -Path $file -Destination $destFolder}
            Add-content $logfilepath -value "File moved to destination in $($elapsedtime.TotalSeconds) seconds"
            if (Test-Path $destFile) {
                Remove-Item $file
            }
        }
        }
        catch{Add-content $logfilepath -value "Error during SyncFiles: $($Error[0])"}
    }

    $path = $Event.SourceEventArgs.FullPath
    $changeType = $Event.SourceEventArgs.ChangeType
    $sourcefolder = $event.MessageData.sourcefolder
    $destinationfolder = $event.MessageData.destinationfolder
    $maxwaitsecs = $event.MessageData.maxwaitsecs
    $logfilepath = $event.MessageData.logfilepath
    Add-content $logfilepath -value "$(Get-Date) ----------- Event triggered by $changeType of $($path) -------------------"
    SyncFiles -sourcefolder $sourcefolder -destinationfolder $destinationfolder -maxwaitsecs $maxwaitsecs
}    

### DECIDE WHICH EVENTS SHOULD BE WATCHED 
#The Register-ObjectEvent cmdlet subscribes to events that are generated by .NET objects on the local computer or on a remote computer.
#When the subscribed event is raised, it is added to the event queue in your session. To get events in the event queue, use the Get-Event cmdlet.
$args = new-object psobject -property @{sourcefolder = $sourcefolder; destinationfolder = $destinationfolder; maxwaitsecs = $maxwaitsecs; logfilepath = $logfilepath}
Register-ObjectEvent $filewatcher "Created" -Action $writeaction -MessageData $args
#Register-ObjectEvent $filewatcher "Changed" -Action $writeaction
#Register-ObjectEvent $filewatcher "Deleted" -Action $writeaction
#Register-ObjectEvent $filewatcher "Renamed" -Action $writeaction

#Get-EventSubscriber -Force
#Get-EventSubscriber | Unregister-Event